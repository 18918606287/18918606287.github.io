<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode Solution: #300 Longest Increasing Subsequence]]></title>
    <url>%2F2019%2F09%2F01%2FLeetCode-Solution-300-Longest-Increasing-Subsequence%2F</url>
    <content type="text"><![CDATA[IntroductionIn this article I will describe two dynamic programming algorithms solving LIS problem and STL functions lower_bound() and upper_bound().Description Given an unsorted array of integers, find the length of longest increasing subsequence.Example:123Input: $[10,9,2,5,3,7,101,18]$Output: 4Explanation: The longest increasing subsequence is $[2,3,7,101]$, therefore the length is $4$. $O(n^2)$ Dynamic Programming Solution]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Algorithm</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Solution: #146 LRUcache]]></title>
    <url>%2F2019%2F08%2F28%2FLeetcode-Solution-LRUcache%2F</url>
    <content type="text"><![CDATA[DescriptionDesign and implement a data structure for Least Recent Used(LRU) cache. It should support the following operations: get and put.get(key) -Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) -Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. Basic IdeaTo solve this problem, we need to design a kind of data structure with the properties as follow: The data structure can visit the and set/insert the item as soon as possible(such as vector or map). The data structure can order the data by the operation time. The data structure can quickly check for the overflow of capacity. Due to the data structure in different language is not the same, I will choose python and cpp as my solution language. Python solutionI will introduce a kind of python data structure called OrderedDict. This is a kind of dictionary(in fact it is inherited from ‘dictionary’ of python) with the order of insertion time. Python uses an extra circular linked list to save the node as form $[PREV, NEXT, KEY]$ to realize the data structure. Obviously, this data structure is perfectly suitable for our problem. The only problem we need to solve is the question is to find a data structure ordering by operation time but not the insertion time. So we just need to simply delete and insert every operation to solve this problem. 12345678910111213141516171819202122232425262728class LRUCache: import collections def __init__(self, capacity: int): self.capacity = capacity self.cache = collections.OrderedDict() def get(self, key: int) -&gt; int: if key in self.cache: ret = self.cache[key] del self.cache[key] self.cache[key] = ret return ret return -1 def put(self, key: int, value: int) -&gt; None: if key in self.cache: del self.cache[key] if self.capacity == len(self.cache): #This for iteration is to visit the first value of cache. for i in self.cache.keys(): del self.cache[i] break self.cache[key] = value# Your LRUCache object will be instantiated and called as such:# obj = LRUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value) Cpp solution(using STL container)CPP provides many kinds of STL containers, but there are nothing like the ‘OrderedDict’ in python. The design idea is to combine two or more kinds of containers(like the OrderedDict source code do). If we want to build a structure with insertion order, stack will be a first choice. But what we also want is to keep the high speed of insertion and deletion of map/vector, which will conflict with stack’s properties that we can not move/delete a node in the middle of a stack. Therefore, Linked List(in STL is list) will be a great choice, which also matches python’s choice. To keep the order of operation time, the problem we need to solve can be as follow: We need a fast way to visit/insert/delete a node in linked list given key. We need a fast way to move a node to the front of linked list after every operation. When we get the first value of linked list, we need a fast way to delete the pair in map/vector. These properties keeps a linked list by operation time order with short modifying time. Actually, property $1$ and $2$ can be combined due to the property of Linked List. Map can be a good way to satisfy property $1$ and $2$. We can use map(key, node) form to visit a linked list node quickly in $O(1)$ time. About property $3$, we need a reverse_map(value, key) to fast delete corresponding pair in map. We just need to delete reverse_map[node.value] in map. But it’s not convenient and cost extra space. We can just store node(value, key) in linked list to do the same thing. In conclusion, what we need is to combine a map(or unordered_map) and a list. 1234567891011121314151617181920212223242526272829303132class LRUCache &#123;public: LRUCache(int capacity) &#123; this-&gt;cache = map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt;(); this-&gt;linkedlist = list&lt;pair&lt;int, int&gt;&gt;(); this-&gt;cap = capacity; &#125; int get(int key) &#123; auto it = cache.find(key); if(it != cache.end())&#123; linkedlist.splice(linkedlist.begin(), linkedlist, it-&gt;second); return it-&gt;second-&gt;second; &#125; else return -1; &#125; void put(int key, int value) &#123; auto it = cache.find(key); if(it != cache.end()) linkedlist.erase(it-&gt;second); linkedlist.push_front(&#123;key, value&#125;); cache[key] = linkedlist.begin(); if(cache.size() &gt; cap)&#123; int key_recent = linkedlist.back().first; cache.erase(key_recent); linkedlist.pop_back(); &#125; &#125;private: map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; cache; list&lt;pair&lt;int, int&gt;&gt; linkedlist; int cap;&#125;; There are also some tricky cases like we need to check for if key in the cache first because change a value in cache need to delete the value first and then insert a new one. The combination of STL containers is not the only way to solve this problem. Actually many artificial data structures have better performance. A specific example is using circular linked list nodes just like python do in the ‘OrderedDict’. I won’t cover this method here and you can find related articles easily.]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Data Structure</tag>
        <tag>Cpp</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Solution: #142 Linked List Circle]]></title>
    <url>%2F2019%2F08%2F27%2FLeetcode-Solution-Linked-List-Circle-0%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a linked list and return where the circle begins. For example, a linked list $[3, 2, 0, 4]$ having circle $[2, 0, 4]$ is shown below.The algorithm should return the second node. I use C++ to solve this problem and define the node as below. 123456//Definition for singly-linked list.struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;; Solution 1: hashsetA trivial idea to solve this problem is saving the node information in a hashset when traversing and find if there is a visited node.123456789101112131415class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode *cur = head; unordered_set&lt;ListNode*&gt; storage; while(cur!=NULL)&#123; if (storage.find(cur)!=storage.end())&#123; return cur; &#125; storage.insert(cur); cur = cur-&gt;next; &#125; return NULL; &#125;&#125;; This is a method with O(n) time complexity and O(n) space complexity. But if there is a method to solve this problem with O(1) space complexity? Solution 2: fast and slow pointersSet two pointers which slower one move one time one step and faster one move one time two steps. Once they meet, reset the faster one to the head pointer, then finally they will meet in the begin node of circle. This is an algorithm without extra space. But why it works? There is a mathematical idea. Suppose the distance from head node to the begin of circle is $x_1$, the distance from begin of circle and meeting point on the circle is $x_2$, the distance from meeting point back to the begin of the circle is $x_3$. Then there is the velocity equation. 2*((x_1 + x_2) + k_1(x_2+x_3)) = (x_1 + x_2) + k_2 (x_2+x_3)-> x_1 + x_2 = (k_2 - 2*k_1 - 1)(x_2 + x_3)-> (x_2 + x_3)|(x_1 + x_2)It means that the difference between $x_3$ and $x_1$ is the multiple of circle length. Due to the definition of $x_3$ and $x_1$, if the fast pointer move from the head node when the slow pointer move from the meeting point, finally the slow pointer and fast pointer will meet on the begin of the circle. 12345678910111213141516171819class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL || head-&gt;next-&gt;next == NULL) return NULL; ListNode* fast = head-&gt;next-&gt;next; ListNode* slow = head-&gt;next; while(fast != slow)&#123; if(fast-&gt;next == NULL || fast-&gt;next-&gt;next == NULL) return NULL; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; fast = head; while(fast != slow)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return slow; &#125;&#125;; Don’t forget the special cases of NULL pointer and if fast pointer move to NULL means there is no circle.]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
