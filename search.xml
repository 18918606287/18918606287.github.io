<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode Solution: #300 Longest Increasing Subsequence]]></title>
    <url>%2F2019%2F09%2F01%2FLeetCode-Solution-300-Longest-Increasing-Subsequence%2F</url>
    <content type="text"><![CDATA[IntroductionIn this article I will describe two dynamic programming algorithms solving LIS problem and STL functions lower_bound() and upper_bound().Description Given an unsorted array of integers, find the length of longest increasing subsequence.Example:123Input: $[10,9,2,5,3,7,101,18]$Output: 4Explanation: The longest increasing subsequence is $[2,3,7,101]$, therefore the length is $4$. Basic IdeaThis problem is an optimal problem, so it’s easy to think about dynamic programming method. So we need to construct a state description which has following properties. It has optimal substructure, which means the optimal solution of the state can be described with its substructure. We can find the state transition equation easily. $O(n^2)$ Dynamic Programming SolutionHere is a trivial description that dp[i] means the length of longest increasing subsequence with $i^{th}$ element. Also, we can find easily that the value of dp[i] can be determined by all increasing subsequence with $j &lt; i$ that maintain increasing property with $i^{th}$ value. Mathematically, dp[i] is determined by all the value dp[j] with $j &lt; i$ and $nums[i] &gt; nums[j]$ which nums is the input vector. So the state transition equation is dp[i] = max(dp[j]) + 1 with j < i && nums[j] < nums[i].This method need two iterations so it’s a $O(n^2)$ algorithm. 1234567891011121314151617class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; dp(n, 0); int ret = 0; for(int i = 0; i &lt; n; i++)&#123; int maximal = 0; for(int j = 0; j &lt; i; j++) if(nums[j] &lt; nums[i]) maximal = max(maximal, dp[j]); dp[i] = maximal + 1; ret = max(ret, dp[i]); &#125; return ret; &#125;&#125;; $O(nlgn)$ Dynamic Programming SolutionComparing all optimal subsequences with the same length, the one with least last number will confirm that when a new number is added in, the new subsequence will still optimal. For example, for subsequence $[1,3,5,2,7,4,5]$, we have two subsequences length $4$: [1,3,5,7] [1,2,4,5].Then we add $6$ into the sequence, the first subsequence is still $[1,3,5,7]$ when the second one becomes $[1,2,4,5,6]$. But how to guarantee that the subsequence has the least last number? We can do so by replacing the number just larger than the new number with the new number. It’s because the replacement won’t change the length of the subsequence but will decrease the number value generally. There is a very great property that the increasing subsequences are ‘increasing’, which means that given a increasing subsequence and a new number, we can find the correct position of the new number in the subsequence in only $O(lgn)$ time. We can generate a new largest increasing subsequence including the new number by adding the new number if it’s larger than all numbers in the subsequence and do replacing if not. The whole time complexity will be $O(nlgn)$. 1234567891011121314class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; dp; int ret = 0; for(int i = 0; i &lt; n; i++)&#123; auto it = lower_bound(dp.begin(), dp.end(), nums[i]); if(it == dp.end()) dp.push_back(nums[i]); else *it = nums[i]; &#125; return dp.size(); &#125;&#125;; lower_bound and upper_bound in STLWe can mention that I use lower_bound function in the previous code. It’s a binary search function in STL. Both it ans upper_bound use binary search and return a position of a vector. The difference is that lower_bound return the position of the first number larger than or equals to the target and upper_bound return the position of the first number strictly larger than the target. There are three parameters in both functions. The first parameter is a Iterator refers to the search begin position, the second parameter is a Iterator refers to the end position and the third parameter is target number. Here is the source code of lower_bound. 1234567891011121314151617template &lt;class ForwardIterator, class T&gt; ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T&amp; val)&#123; ForwardIterator it; iterator_traits&lt;ForwardIterator&gt;::difference_type count, step; count = distance(first,last); while (count&gt;0) &#123; it = first; step=count/2; advance (it,step); if (*it&lt;val) &#123; // or: if (comp(*it,val)), for version (2) first=++it; count-=step+1; &#125; else count=step; &#125; return first;&#125; What should be mentioned is that the begin position will be included but the end position won’t be included. The function uses binary search, so the time complexity is $O(lgn)$ where $n$ is the size between two pointers.]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Algorithm</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Solution: #146 LRUcache]]></title>
    <url>%2F2019%2F08%2F28%2FLeetcode-Solution-LRUcache%2F</url>
    <content type="text"><![CDATA[DescriptionDesign and implement a data structure for Least Recent Used(LRU) cache. It should support the following operations: get and put.get(key) -Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) -Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. Basic IdeaTo solve this problem, we need to design a kind of data structure with the properties as follow: The data structure can visit the and set/insert the item as soon as possible(such as vector or map). The data structure can order the data by the operation time. The data structure can quickly check for the overflow of capacity. Due to the data structure in different language is not the same, I will choose python and cpp as my solution language. Python solutionI will introduce a kind of python data structure called OrderedDict. This is a kind of dictionary(in fact it is inherited from ‘dictionary’ of python) with the order of insertion time. Python uses an extra circular linked list to save the node as form $[PREV, NEXT, KEY]$ to realize the data structure. Obviously, this data structure is perfectly suitable for our problem. The only problem we need to solve is the question is to find a data structure ordering by operation time but not the insertion time. So we just need to simply delete and insert every operation to solve this problem. 12345678910111213141516171819202122232425262728class LRUCache: import collections def __init__(self, capacity: int): self.capacity = capacity self.cache = collections.OrderedDict() def get(self, key: int) -&gt; int: if key in self.cache: ret = self.cache[key] del self.cache[key] self.cache[key] = ret return ret return -1 def put(self, key: int, value: int) -&gt; None: if key in self.cache: del self.cache[key] if self.capacity == len(self.cache): #This for iteration is to visit the first value of cache. for i in self.cache.keys(): del self.cache[i] break self.cache[key] = value# Your LRUCache object will be instantiated and called as such:# obj = LRUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value) Cpp solution(using STL container)CPP provides many kinds of STL containers, but there are nothing like the ‘OrderedDict’ in python. The design idea is to combine two or more kinds of containers(like the OrderedDict source code do). If we want to build a structure with insertion order, stack will be a first choice. But what we also want is to keep the high speed of insertion and deletion of map/vector, which will conflict with stack’s properties that we can not move/delete a node in the middle of a stack. Therefore, Linked List(in STL is list) will be a great choice, which also matches python’s choice. To keep the order of operation time, the problem we need to solve can be as follow: We need a fast way to visit/insert/delete a node in linked list given key. We need a fast way to move a node to the front of linked list after every operation. When we get the first value of linked list, we need a fast way to delete the pair in map/vector. These properties keeps a linked list by operation time order with short modifying time. Actually, property $1$ and $2$ can be combined due to the property of Linked List. Map can be a good way to satisfy property $1$ and $2$. We can use map(key, node) form to visit a linked list node quickly in $O(1)$ time. About property $3$, we need a reverse_map(value, key) to fast delete corresponding pair in map. We just need to delete reverse_map[node.value] in map. But it’s not convenient and cost extra space. We can just store node(value, key) in linked list to do the same thing. In conclusion, what we need is to combine a map(or unordered_map) and a list. 1234567891011121314151617181920212223242526272829303132class LRUCache &#123;public: LRUCache(int capacity) &#123; this-&gt;cache = map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt;(); this-&gt;linkedlist = list&lt;pair&lt;int, int&gt;&gt;(); this-&gt;cap = capacity; &#125; int get(int key) &#123; auto it = cache.find(key); if(it != cache.end())&#123; linkedlist.splice(linkedlist.begin(), linkedlist, it-&gt;second); return it-&gt;second-&gt;second; &#125; else return -1; &#125; void put(int key, int value) &#123; auto it = cache.find(key); if(it != cache.end()) linkedlist.erase(it-&gt;second); linkedlist.push_front(&#123;key, value&#125;); cache[key] = linkedlist.begin(); if(cache.size() &gt; cap)&#123; int key_recent = linkedlist.back().first; cache.erase(key_recent); linkedlist.pop_back(); &#125; &#125;private: map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; cache; list&lt;pair&lt;int, int&gt;&gt; linkedlist; int cap;&#125;; There are also some tricky cases like we need to check for if key in the cache first because change a value in cache need to delete the value first and then insert a new one. The combination of STL containers is not the only way to solve this problem. Actually many artificial data structures have better performance. A specific example is using circular linked list nodes just like python do in the ‘OrderedDict’. I won’t cover this method here and you can find related articles easily.]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Data Structure</tag>
        <tag>Cpp</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Solution: #142 Linked List Circle]]></title>
    <url>%2F2019%2F08%2F27%2FLeetcode-Solution-Linked-List-Circle-0%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a linked list and return where the circle begins. For example, a linked list $[3, 2, 0, 4]$ having circle $[2, 0, 4]$ is shown below.The algorithm should return the second node. I use C++ to solve this problem and define the node as below. 123456//Definition for singly-linked list.struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;; Solution 1: hashsetA trivial idea to solve this problem is saving the node information in a hashset when traversing and find if there is a visited node.123456789101112131415class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode *cur = head; unordered_set&lt;ListNode*&gt; storage; while(cur!=NULL)&#123; if (storage.find(cur)!=storage.end())&#123; return cur; &#125; storage.insert(cur); cur = cur-&gt;next; &#125; return NULL; &#125;&#125;; This is a method with O(n) time complexity and O(n) space complexity. But if there is a method to solve this problem with O(1) space complexity? Solution 2: fast and slow pointersSet two pointers which slower one move one time one step and faster one move one time two steps. Once they meet, reset the faster one to the head pointer, then finally they will meet in the begin node of circle. This is an algorithm without extra space. But why it works? There is a mathematical idea. Suppose the distance from head node to the begin of circle is $x_1$, the distance from begin of circle and meeting point on the circle is $x_2$, the distance from meeting point back to the begin of the circle is $x_3$. Then there is the velocity equation. 2*((x_1 + x_2) + k_1(x_2+x_3)) = (x_1 + x_2) + k_2 (x_2+x_3)-> x_1 + x_2 = (k_2 - 2*k_1 - 1)(x_2 + x_3)-> (x_2 + x_3)|(x_1 + x_2)It means that the difference between $x_3$ and $x_1$ is the multiple of circle length. Due to the definition of $x_3$ and $x_1$, if the fast pointer move from the head node when the slow pointer move from the meeting point, finally the slow pointer and fast pointer will meet on the begin of the circle. 12345678910111213141516171819class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL || head-&gt;next-&gt;next == NULL) return NULL; ListNode* fast = head-&gt;next-&gt;next; ListNode* slow = head-&gt;next; while(fast != slow)&#123; if(fast-&gt;next == NULL || fast-&gt;next-&gt;next == NULL) return NULL; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; fast = head; while(fast != slow)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return slow; &#125;&#125;; Don’t forget the special cases of NULL pointer and if fast pointer move to NULL means there is no circle.]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
