<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode Solution: Best Time to Buy and Sell Stock]]></title>
    <url>%2F2019%2F09%2F05%2FLeetCode-Solution-Best-Time-Stock-to-Buy-and-Sell-Stock%2F</url>
    <content type="text"><![CDATA[IntroductionIn this article I will try to solve Best Time to Buy and Sell Stock series problem, including Best Time to Buy and Sell Stock I, II, III, IV and with Cooldown. Most of them are solved by dynamic programming and I will focus on construct transition equation and dimension reduction. DescriptionThe description of Best Time to Buy and Sell Stock I is: Say you have an array for which the $i^{th}$ element is the price of a given stock on day $i$. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example:123Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Solution of Problem IA simple idea is using dp[i] as the most profit buying in $i^{th}$ day. Then the transition equation will be dp[i] = max(prices[j] - prices[i]) for all j &gt; i and the soluton is max(dp). It will be an $O(n^2)$ algorithm. But there is a waste of computation in this method. We suppose $j$ is the specific day that dp[i] = prices[j] - prices[i], then if there is a $k$ makes $dp[k] &lt; dp[i]$ and $k &gt; i$, then we have dp[k] = max(prices[l] - prices[i]) > prices[j] - prices[k] > dp[i].So the soluton won’t be dp[i]. Under this circumstance, we cam simplify our algorithm by always searching lower price day as buying day, record the current price minus buying day price(the lowest price before/on current $i^{th}$ day) and generate a sequence of profit. The profit[i] means the difference between $i^{th}$ day price and the lowest price before/on $i^{th}$ day. So max(profit) will be the solution. By doing so, we reduce the method into $O(n)$ time. Here is the cpp code. 123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; int buy = prices[0]; int maxPro = 0; for(int price:prices)&#123; if(price &lt; buy)&#123; buy = price; &#125; maxPro = max(maxPro, price-buy); &#125; return maxPro; &#125;&#125;; Solution of Problem IIIn problem II, we have not the transaction number limitation, we can buy/sell any times. When we try to using the dp[i] as above, we find that it’s hard to build a transition equation because we don’t know how many transaction times there will be. We have to change our state description. We have only three actions in a day, buying, selling and doing nothing, so we can use two states to describe a day, i.e. a day with stock and a day without stock. Let nohold[i] be the maximal profit when we have not stock in $i^{th}$ day, hold[i] be the maximal profit when we have stock. Then the transition equation will be 12hold[i] = max(hold[i-1], nohold[i-1] - prices[i]);nohold[i] = max(hold[i-1] + prices[i], nohold[i-1]); That simply means if we have stock in $i^{th}$ day, the stock can be bought today or we already have it yesterday and if we have stock in $i^{th}$ day, the stock can be sold today or yesterday or before. By this equation, we can solve this problem in one pass. Don’t forget the initialization nohold[0] = -prices[0]. 1234567891011121314class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; vector&lt;int&gt; nohold(prices.size(), 0); vector&lt;int&gt; hold(prices.size(), 0); hold[0] = -prices[0]; for(int i = 1; i &lt; prices.size(); i++)&#123; hold[i] = max(hold[i-1], nohold[i-1] - prices[i]); nohold[i] = max(hold[i-1] + prices[i], nohold[i-1]); &#125; return nohold[nohold.size()-1]; &#125;&#125;; There is another solution do not use DP. A trivial idea is that we buy all the stock at the begin of an increasing line and sell it at the end of line, we can get the most profit. 12345678910class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int maximal = 0; for(int i = 1; i &lt; prices.size(); i++)&#123; if(prices[i] &gt; prices[i-1]) maximal += prices[i] - prices[i-1]; &#125; return maximal; &#125;&#125;; Soluton of III &amp; IVProblem III is a special case of Problem IV, so we just introduce Problem IV. In Problem IV, we have a limitation that we can only buy $k$ times($k$ is given). It can be solved simply like the DP algorithm of Problem II. We can use similar state description and just increase a dimension of transaction times. Let hold[i][j] as the maximal profit when we have stock and $j$ transitions on $i^{th}$ day and nohold[i][j] as the maximal profit when we have no stock and have $j$ transitions on $i^{th}$ day. Also like Problem II, the transition equation can be written as 12hold[i][j] = max(hold[i-1][j], nohold[i-1][j-1] - prices[i]);nohold[i][j] = max(nohold[i-1][j], hold[i-1][j] + prices[i]); The solution will be nohold[n-1][k-1]. What need to be mentioned is that we counting transaction by counting buying numbers but not selling. Then it’s a one-pass method. 12345678910111213141516171819202122class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(prices.empty() || k==0) return 0; int n = prices.size(); vector&lt;vector&lt;int&gt;&gt; hold(n, vector&lt;int&gt;(k, 0)), nohold(n, vector&lt;int&gt;(k, 0)); //hold[0][0] = -prices[0]; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; k; j++)&#123; if(i &gt; 0)&#123; if(j &gt; 0) hold[i][j] = max(hold[i-1][j], nohold[i-1][j-1] - prices[i]); else hold[i][j] = max(hold[i-1][j], -prices[i]); nohold[i][j] = max(nohold[i-1][j], hold[i-1][j] + prices[i]); &#125; else hold[i][j] = -prices[i]; &#125; &#125; return nohold[n-1][k-1]; &#125;&#125;; But the code did not pass! We got a Memory Limit Exceeded. So I start to reduce the dimension of the equation. Obviously, both hold[i][j] and nohold[i][j] have only relationship with hold[i-1][*] and nohold[i-1][*]. So we can just reduce it as 12hold[j] = max(hold[j], nohold[j-1] - prices[i]);nohold[j] = max(nohold[j], hold[j] + prices[i]); Also, using a sentinel $0$ in nohold[j] can make code looks better(reduce the number of $if$). So we get the code like this. 12345678910111213141516class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(prices.empty() || k==0) return 0; int n = prices.size(); vector&lt;int&gt; hold(k, INT_MIN), nohold(k+1, 0); hold[0] = -prices[0]; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; k; j++)&#123; hold[j] = max(hold[j], nohold[j] - prices[i]); nohold[j+1] = max(nohold[j+1], hold[j] + prices[i]); &#125; &#125; return nohold[k]; &#125;&#125;; ~Ok, we have already solved it!~ Wait, it’s still Memory Limit Exceeded! But why? If we consider a super large $k$ that the limitation is meaningless to the problem, the problem reduces into Problem II. But the time complexity of our solution will still be $O(k*\dot n)$, which is a super large number especially comparing with $O(n)$ solution in Problem II. We can solve this by a simple $if$ sentence. 123456if(k &gt; n/2)&#123; int res = 0; for(int i = 1; i &lt; prices.size(); i++) res = max(res, res + prices[i]-prices[i-1]); return res;&#125; And here is the whole program of Problem IV. 1234567891011121314151617181920212223class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(prices.empty() || k==0) return 0; int n = prices.size(); if(k &gt; n/2)&#123; int res = 0; for(int i = 1; i &lt; prices.size(); i++) res = max(res, res + prices[i]-prices[i-1]); return res; &#125; vector&lt;int&gt; hold(k, INT_MIN), nohold(k+1, 0); hold[0] = -prices[0]; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; k; j++)&#123; hold[j] = max(hold[j], nohold[j] - prices[i]); nohold[j+1] = max(nohold[j+1], hold[j] + prices[i]); &#125; &#125; return nohold[k]; &#125;&#125;; Solution of Problem with CooldownCooldown means we have to ~have relax and take a coffee~ the day after selling. Buying the day after a selling is not allowed. That means our states description above can not be used again…Of course not! We can just do a little modification, adding a new vector called cooldown[i] means the maximal profit when we just sell or do nothing on the $i^{th}$ day. We have have_stock[i] and have_no_stock[i] as above. We can find the transition of cooldown like cooldown[i] = max(hold_no_stock[i-1], hold_stock[i-1] + prices[i]) which means today we sell the stock or do nothing. The transition of hold_stock is still hold_stock[i] = max(hold_stock[i-1], hold_no_stock[i-1] - prices[i]) because cooldown doesn’t influence buying. Finally the transition equation pf hold_no_stock[i] can be hold_no_stock[i] = max(hold_no_stock[i-1], cooldown[i-1]), meaning that today is a cooldown day or no stock day. Combine them together we have_stock 123hold_no_stock[i] = max(hold_no_stock[i-1], cooldown[i-1]);hold_stock[i] = max(hold_stock[i-1], hold_no_stock[i-1] - prices[i]);cooldown[i] = max(hold_no_stock[i-1], hold_stock[i-1] + prices[i]); Don’t forget the initialization hold_stock[0] = -prices[0]; cooldown[0] = INT_MIN;. It’s also a $O(n)$ one-pass method now. In conclusion, all these kind of problem can be solved by dynamic programming idea and the basic idea is to form transition equation. The number of variables or the number of dimensions are equivalent in constructing equation. So if you have not idea how to form the equation, including the variable number of state will be a good choice. 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; int n = prices.size(); vector&lt;int&gt; hold_stock(n, 0), hold_no_stock(n, 0), cooldown(n, 0); hold_stock[0] = -prices[0]; cooldown[0] = INT_MIN; for(int i = 1; i &lt; n; i++)&#123; hold_no_stock[i] = max(hold_no_stock[i-1], cooldown[i-1]); hold_stock[i] = max(hold_stock[i-1], hold_no_stock[i-1] - prices[i]); cooldown[i] = max(hold_no_stock[i-1], hold_stock[i-1] + prices[i]); &#125; return max(cooldown[cooldown.size()-1], hold_no_stock[hold_no_stock.size()-1]); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Solution: #300 Longest Increasing Subsequence]]></title>
    <url>%2F2019%2F09%2F01%2FLeetCode-Solution-300-Longest-Increasing-Subsequence%2F</url>
    <content type="text"><![CDATA[IntroductionIn this article I will describe two dynamic programming algorithms solving LIS problem and STL functions lower_bound() and upper_bound(). DescriptionGiven an unsorted array of integers, find the length of longest increasing subsequence.Example:123Input: $[10,9,2,5,3,7,101,18]$Output: 4Explanation: The longest increasing subsequence is $[2,3,7,101]$, therefore the length is $4$. Basic IdeaThis problem is an optimal problem, so it’s easy to think about dynamic programming method. So we need to construct a state description which has following properties. It has optimal substructure, which means the optimal solution of the state can be described with its substructure. We can find the state transition equation easily. $O(n^2)$ Dynamic Programming SolutionHere is a trivial description that dp[i] means the length of longest increasing subsequence with $i^{th}$ element. Also, we can find easily that the value of dp[i] can be determined by all increasing subsequence with $j &lt; i$ that maintain increasing property with $i^{th}$ value. Mathematically, dp[i] is determined by all the value dp[j] with $j &lt; i$ and $nums[i] &gt; nums[j]$ which nums is the input vector. So the state transition equation is dp[i] = max(dp[j]) + 1 \quad with \quad j < i, nums[j] < nums[i]This method need two iterations so it’s a $O(n^2)$ algorithm. 1234567891011121314151617class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; dp(n, 0); int ret = 0; for(int i = 0; i &lt; n; i++)&#123; int maximal = 0; for(int j = 0; j &lt; i; j++) if(nums[j] &lt; nums[i]) maximal = max(maximal, dp[j]); dp[i] = maximal + 1; ret = max(ret, dp[i]); &#125; return ret; &#125;&#125;; $O(nlgn)$ Dynamic Programming SolutionComparing all optimal subsequences with the same length, the one with least last number will confirm that when a new number is added in, the new subsequence will still optimal. For example, for subsequence $[1,3,5,2,7,4,5]$, we have two subsequences length $4$: [1,3,5,7], [1,2,4,5]Then we add $6$ into the sequence, the first subsequence is still $[1,3,5,7]$ when the second one becomes $[1,2,4,5,6]$. But how to guarantee that the subsequence has the least last number? We can do so by replacing the number just larger than the new number with the new number. It’s because the replacement won’t change the length of the subsequence but will decrease the number value generally. There is a very great property that the increasing subsequences are ‘increasing’, which means that given a increasing subsequence and a new number, we can find the correct position of the new number in the subsequence in only $O(lgn)$ time. We can generate a new largest increasing subsequence including the new number by adding the new number if it’s larger than all numbers in the subsequence and do replacing if not. The whole time complexity will be $O(nlgn)$. 1234567891011121314class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; dp; int ret = 0; for(int i = 0; i &lt; n; i++)&#123; auto it = lower_bound(dp.begin(), dp.end(), nums[i]); if(it == dp.end()) dp.push_back(nums[i]); else *it = nums[i]; &#125; return dp.size(); &#125;&#125;; lower_bound and upper_bound in STLWe can mention that I use lower_bound function in the previous code. It’s a binary search function in STL. Both it ans upper_bound use binary search and return a position of a vector. The difference is that lower_bound return the position of the first number larger than or equals to the target and upper_bound return the position of the first number strictly larger than the target. There are three parameters in both functions. The first parameter is a Iterator refers to the search begin position, the second parameter is a Iterator refers to the end position and the third parameter is target number. Here is the source code of lower_bound. 1234567891011121314151617template &lt;class ForwardIterator, class T&gt; ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T&amp; val)&#123; ForwardIterator it; iterator_traits&lt;ForwardIterator&gt;::difference_type count, step; count = distance(first,last); while (count&gt;0) &#123; it = first; step=count/2; advance (it,step); if (*it&lt;val) &#123; // or: if (comp(*it,val)), for version (2) first=++it; count-=step+1; &#125; else count=step; &#125; return first;&#125; What should be mentioned is that the begin position will be included but the end position won’t be included. The function uses binary search, so the time complexity is $O(lgn)$ where $n$ is the size between two pointers.]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Algorithm</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Solution: #146 LRUcache]]></title>
    <url>%2F2019%2F08%2F28%2FLeetcode-Solution-LRUcache%2F</url>
    <content type="text"><![CDATA[DescriptionDesign and implement a data structure for Least Recent Used(LRU) cache. It should support the following operations: get and put. get(key) -Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) -Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. Basic IdeaTo solve this problem, we need to design a kind of data structure with the properties as follow: The data structure can visit the and set/insert the item as soon as possible(such as vector or map). The data structure can order the data by the operation time. The data structure can quickly check for the overflow of capacity. Due to the data structure in different language is not the same, I will choose python and cpp as my solution language. Python solutionI will introduce a kind of python data structure called OrderedDict. This is a kind of dictionary(in fact it is inherited from ‘dictionary’ of python) with the order of insertion time. Python uses an extra circular linked list to save the node as form $[PREV, NEXT, KEY]$ to realize the data structure. Obviously, this data structure is perfectly suitable for our problem. The only problem we need to solve is the question is to find a data structure ordering by operation time but not the insertion time. So we just need to simply delete and insert every operation to solve this problem. 12345678910111213141516171819202122232425262728class LRUCache: import collections def __init__(self, capacity: int): self.capacity = capacity self.cache = collections.OrderedDict() def get(self, key: int) -&gt; int: if key in self.cache: ret = self.cache[key] del self.cache[key] self.cache[key] = ret return ret return -1 def put(self, key: int, value: int) -&gt; None: if key in self.cache: del self.cache[key] if self.capacity == len(self.cache): #This for iteration is to visit the first value of cache. for i in self.cache.keys(): del self.cache[i] break self.cache[key] = value# Your LRUCache object will be instantiated and called as such:# obj = LRUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value) Cpp solution(using STL container)CPP provides many kinds of STL containers, but there are nothing like the ‘OrderedDict’ in python. The design idea is to combine two or more kinds of containers(like the OrderedDict source code do). If we want to build a structure with insertion order, stack will be a first choice. But what we also want is to keep the high speed of insertion and deletion of map/vector, which will conflict with stack’s properties that we can not move/delete a node in the middle of a stack. Therefore, Linked List(in STL is list) will be a great choice, which also matches python’s choice. To keep the order of operation time, the problem we need to solve can be as follow: We need a fast way to visit/insert/delete a node in linked list given key. We need a fast way to move a node to the front of linked list after every operation. When we get the first value of linked list, we need a fast way to delete the pair in map/vector. These properties keeps a linked list by operation time order with short modifying time. Actually, property $1$ and $2$ can be combined due to the property of Linked List. Map can be a good way to satisfy property $1$ and $2$. We can use map(key, node) form to visit a linked list node quickly in $O(1)$ time. About property $3$, we need a reverse_map(value, key) to fast delete corresponding pair in map. We just need to delete reverse_map[node.value] in map. But it’s not convenient and cost extra space. We can just store node(value, key) in linked list to do the same thing. In conclusion, what we need is to combine a map(or unordered_map) and a list. 1234567891011121314151617181920212223242526272829303132class LRUCache &#123;public: LRUCache(int capacity) &#123; this-&gt;cache = map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt;(); this-&gt;linkedlist = list&lt;pair&lt;int, int&gt;&gt;(); this-&gt;cap = capacity; &#125; int get(int key) &#123; auto it = cache.find(key); if(it != cache.end())&#123; linkedlist.splice(linkedlist.begin(), linkedlist, it-&gt;second); return it-&gt;second-&gt;second; &#125; else return -1; &#125; void put(int key, int value) &#123; auto it = cache.find(key); if(it != cache.end()) linkedlist.erase(it-&gt;second); linkedlist.push_front(&#123;key, value&#125;); cache[key] = linkedlist.begin(); if(cache.size() &gt; cap)&#123; int key_recent = linkedlist.back().first; cache.erase(key_recent); linkedlist.pop_back(); &#125; &#125;private: map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; cache; list&lt;pair&lt;int, int&gt;&gt; linkedlist; int cap;&#125;; There are also some tricky cases like we need to check for if key in the cache first because change a value in cache need to delete the value first and then insert a new one. The combination of STL containers is not the only way to solve this problem. Actually many artificial data structures have better performance. A specific example is using circular linked list nodes just like python do in the ‘OrderedDict’. I won’t cover this method here and you can find related articles easily.]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Data Structure</tag>
        <tag>Cpp</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Solution: #142 Linked List Circle]]></title>
    <url>%2F2019%2F08%2F27%2FLeetcode-Solution-Linked-List-Circle-0%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a linked list and return where the circle begins. For example, a linked list $[3, 2, 0, 4]$ having circle $[2, 0, 4]$ is shown below. The algorithm should return the second node. I use C++ to solve this problem and define the node as below. 123456//Definition for singly-linked list.struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;; Solution 1: hashsetA trivial idea to solve this problem is saving the node information in a hashset when traversing and find if there is a visited node.123456789101112131415class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode *cur = head; unordered_set&lt;ListNode*&gt; storage; while(cur!=NULL)&#123; if (storage.find(cur)!=storage.end())&#123; return cur; &#125; storage.insert(cur); cur = cur-&gt;next; &#125; return NULL; &#125;&#125;; This is a method with O(n) time complexity and O(n) space complexity. But if there is a method to solve this problem with O(1) space complexity? Solution 2: fast and slow pointersSet two pointers which slower one move one time one step and faster one move one time two steps. Once they meet, reset the faster one to the head pointer, then finally they will meet in the begin node of circle. This is an algorithm without extra space. But why it works? There is a mathematical idea. Suppose the distance from head node to the begin of circle is $x_1$, the distance from begin of circle and meeting point on the circle is $x_2$, the distance from meeting point back to the begin of the circle is $x_3$. Then there is the velocity equation. 2*((x_1 + x_2) + k_1(x_2+x_3)) = (x_1 + x_2) + k_2 (x_2+x_3)-> x_1 + x_2 = (k_2 - 2*k_1 - 1)(x_2 + x_3)-> (x_2 + x_3)|(x_1 + x_2)It means that the difference between $x_3$ and $x_1$ is the multiple of circle length. Due to the definition of $x_3$ and $x_1$, if the fast pointer move from the head node when the slow pointer move from the meeting point, finally the slow pointer and fast pointer will meet on the begin of the circle. 12345678910111213141516171819class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL || head-&gt;next-&gt;next == NULL) return NULL; ListNode* fast = head-&gt;next-&gt;next; ListNode* slow = head-&gt;next; while(fast != slow)&#123; if(fast-&gt;next == NULL || fast-&gt;next-&gt;next == NULL) return NULL; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; fast = head; while(fast != slow)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return slow; &#125;&#125;; Don’t forget the special cases of NULL pointer and if fast pointer move to NULL means there is no circle.]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
