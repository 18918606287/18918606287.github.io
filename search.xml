<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Machine Learning Basis: Lagrange Duality and KKT Condition]]></title>
    <url>%2F2019%2F11%2F04%2FMachine-Learning-Basis-Lagrange-Duality-and-KKT-Condition%2F</url>
    <content type="text"><![CDATA[IntroductionDuality and KKT condition are very important for machine learning, especially in SVM models. I’ll focus more on the high-level idea and the derivation of Lagrange Duality and how to introduce to KKT condition. There are some connceptions should be covered first. Optimization Problems without RestrictionsThe basic form of optimization problem without restrictions is just like finding the $x \in \Re^d$ makes that min_{x\in \Re^d} f(x)A simple solution is to calculate the derivatives of $f(x)$, solve the equation f'(x^*) = 0 and test if x^* is the minimal value. Lagrange MultiplierConsider an Optimization Problem with equality restrictions. min_{x\in \Re^d} f(x) s.t. h_i(x) = 0Lagrange Multiplier is a method to solve this kind of problem. We can rewrite the objective function as f(x) + \sum^n_{i=1}\lambda_i h_i(x). Then we can prove that the solution of min_{x\in \Re^d,\lambda_i\in \Re }f(x) + \sum^n_{i=1}\lambda_i h_i(x) is equal to the solution of previous problem. Here \lambda_i are called the Lagrange Multiplier. The new optimization problem is min_{x\in \Re^d} f(x) + \sum^n_{i=1}\lambda_i h_i(x)And here the new function \mathcal{L}(x,\lambda) = f(x) + \sum^n_{i=1}\lambda_i h_i(x) is called Lagrange function. If there is any h_i(x) \neq0, the minimum will become $-\infty$ due to the unrestricted \lambda_i, so we should add a restriction that \nabla_{x,\lambda}\mathcal{L}(x, \lambda)= 0 which makes the solution finite and converge into h_i(x) = 0. Dual ProblemLet \mathcal{L}(x,\lambda, \mu) = f(x) + \sum_{i=1}^n\lambda_i h_i(x) + \sum_{j=1}^m\mu_j g_j(x),then there is a trivial theorem that d^* = max_{\lambda, \mu}(min_{x}(\mathcal{L}(x, \lambda,\mu))) \leq min_{x}({max_{\lambda, \mu}\mathcal{L}(x, \lambda, \mu)}) = p^*Here d^* = max_{\lambda, \mu}(min_{x}(\mathcal{L}(x, \lambda,\mu))) is the dual problem of p^*. DerivationTransformation of Primal ProblemAssume f(x), g_i(x), h_j(x) are continuous functions on \Re^d, then consider the restricted optimization problem. min_{x\in \Re^d} f(x) s.t.\left\{ \begin{array}{lr} g_i(x) \leq 0\\ h_i(x) = 0 \end{array} \right.We have already known that the primal problem without restrictions can be solved easily by calculating derivatives and testing. So our first step is to translate the primal problem into a problem without restrictions. We have a enhanced Lagrange Function in form of \mathcal{L}(x,\lambda, \mu) = f(x) + \sum_{i=1}^n\lambda_i h_i(x) + \sum_{j=1}^m\mu_j g_j(x). Here \mu_j \geq 0 because the direction of g_j has been restricted. Define a new function d(x) = max_{\lambda,\mu>0}\mathcal{L}(x, \lambda, \mu), we can conclude that min_{x}d(x) = min_{x}f(x) under all primal constraints. Obviously, d(x) \geq max_{\lambda, \mu}f(x) = f(x), so d(x) is an upper bound of f(x). Then under all constraints, we have \sum_{i=1}^n\lambda_i h_i(x) + \sum_{j=1}^m\mu_j g_j(x) = 0, then d(x) = max_{\lambda, \mu}f(x) = f(x). In conclusion, the primal problem has an equivalent form min_{x\in \Re^d}({max_{\lambda, \mu}\mathcal{L}(x, \lambda, \mu)}) s.t.\left\{ \begin{array}{lr} g_i(x) \leq 0\\ h_i(x) = 0 \end{array} \right.KKT conditionWe have already known the equivalent form of primal problem, but in this form we should still consider the constraints which makes the calculation too complicated. The next step is to find a simpler way of finding the best solution. Consider the dual problem, a well property should be d^* = p^* when x = x^* is the best solution of primal problem. Think back the transformation of primal problem, if dual problem is equal to the primal problem on $x = x^*$, the formula should be min_{x}(max_{\lambda, \mu} f(x) + \sum_{i=1}^n\lambda_i h(x) + \sum_{i=1}^m\mu_j g_j(x))= max_{\lambda, \mu}(min_{x}f(x) + \sum_{i=1}^n\lambda_i h(x) + \sum_{i=1}^m\mu_j g_j(x))) s.t.\mu_j \geq 0Then consider the Lagrange condition of both inner optimizations which are max_{\lambda, \mu}\mathcal{L}(x,\lambda,\mu) and min_{x}\mathcal{L}(x,\lambda,\mu). This leads to \nabla_x\mathcal{L}(x^*) = 0 and \nabla_\lambda\mathcal{L} = 0. Then consider the parameter \mu_j. There are two situations about g_j(x). First is that the minimized point is of g_j(x) = 0 and the other is that the minimized point is of g_j(x) < 0. For the first case, the inequality constraint becomes a equality constraint. That is g_j(x) = 0For the second case, the inequality constraint disappears, that is \mu_j = 0So combine two situations together we have \mu_j g_j(x)=0. Then under this constraint, the \mathcal{L} becomes a regular Lagrange Function, which leads to a Lagrange Multiplier constraint that \nabla \mathcal{L}_{x, \lambda} = 0So the final constraint becomes \nabla f(x^*) + \sum_{i=1}^n \lambda_i\nabla h_i(x^*) + \sum_{j=1}^m \lambda_j\nabla g_j(x^*) = 0 h_i(x^*) = 0 \mu_j g_j(x^*) = 0 \mu_j \geq 0This is the KKT condition.]]></content>
      <categories>
        <category>Learning Notes</category>
      </categories>
      <tags>
        <tag>Optimization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Connecting CAEN using VScode]]></title>
    <url>%2F2019%2F10%2F06%2FConnecting-CAEN-using-VScode%2F</url>
    <content type="text"><![CDATA[What and WhyCAEN is the information technology (IT) services department for the University of Michigan (U-M) College of Engineering, and offers IT resources to support the College’s educational, research, and administrative needs. It’s quite unefficient to manage files on CAEN using command line tools if I need to text our code in CAEN environment. I need to type the whole sftp command and path every time. Plugins for editors is a great solution. There are many tutorials about connecting using Sublime Text Editor on the Internet, but there is no documentations about VScode. As a fan of VScode, that’s why I want to write this article. EnvironmentThis is my own running environment may but not necessary. Operating system: Windows 10 VSCode Version: 1.36.1 Plugin: SFTP (by liximomo) Getting StartAfter downloading the plugin, press Ctrl+Shift+P and run SFTP: config command. This command will build a configuration file named sftp.json on your folder (you may need to open a folder) and it may looks like: 123456789&#123; "name": "My Server", "host": "localhost", "protocol": "sftp", "port": 22, "username": "username", "remotePath": "/", "uploadOnSave": true&#125; Name your server casually in name and the type the host address of CAEN machine in host. The host will be something looked like login.engin.umich.edu. It’s not necessary to change the protocol and port. The username is your Umich unique name. Here is the explanation of these parameters. name is your own name of this server, you can name it casually. host is the host address of CAEN machine, like login.engin.umich.edu. protocol is the protocol of connection, you don’t need to change the default sftp. port is the port of the connecting server. username is yout own Umich uniquename which is needed for signing in the server. remotePath is the path on the CEAN machine where will upload your local file to. For example home/username. uploadOnSave is the switch of autouploading to the server. If the value is true, the files will be automatically uploaded to your server when you save your files locally. After all these settings are saved, you will see a new icon on the Activity Bar. Two-factor AuthenticationThe University of Michigan uses two-factor authentication to authenticate your account. So we need to add a new parameter to handle this. Add a new attribute interactiveAuth in the json file and set it to true. So the whole configuration file will looks like 12345678910&#123; "name": "My Server", "host": "xxx.xxx.xxx.xxx", "protocol": "sftp", "port": 22, "username": "username", "remotePath": "/home/username", "uploadOnSave": true, "interactiveAuth": true&#125; ConnectingDouble click the server in the SFTP option on the activity bar with the following icon. After connecting, you will see a input window above looks like Then your will see a two-factor authentication window like input and pass the authentication through app or message, then you will see the dictionary of your server machine. Mention that if you use address &quot;/&quot; in the remotePath, you will connect to the public area and will have not permission to open the private folders including yours.]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>SFTP</tag>
        <tag>Umich</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Machine Learning Basis: Convex Function and Hessian Matrix]]></title>
    <url>%2F2019%2F09%2F09%2FMachine-Learning-Basis-Convex-Function-and-Hessian-Matrix%2F</url>
    <content type="text"><![CDATA[IntroductionOptimization is a focus on many kinds of machine learning algorithms like Linear Regression, SVM and K-means. But actually many kinds of target function is non-convex which means we can only find its local minima. But convex functions still plays an important role in machine learning. And Hessian Matrix is a great algebra tool to analyze convex functions since in most cases our target function will be real, continuous and $2^{nd}$-order differentiable. The main goal of this article is to record the proof of the equivalence between Convex Functions and their Hessians. Here is the some important definitions. Convex SetA Convex Set $C\subseteq \Re^n$ is a set of points s.t. $\forall x, y \in C$ and $t \in [0,1]$, $tx+(1-t)y \in C$. Convex FunctionA function $f:\Re^n \rightarrow \Re$ is a Convex Function if for $x, y \in D$, where $D$ is a convex set, $f$ and any $t \in [0,1]$ makes f(tx + (1-t)y) \leq tf(x) + (1-t)f(y)Hessian MatrixA Hessian Matrix is a square matrix of second-order partial derivatives of a function $f:\Re^n \rightarrow \Re$, usually written as: H = \nabla^2f(x) = \left[ \begin{array}{cc} \frac{\partial^2 f}{\partial x_1\partial x_1} & \frac{\partial^2 f}{\partial x_1\partial x_2} & ... & \frac{\partial^2 f}{\partial x_1\partial x_d}\\ \frac{\partial^2 f}{\partial x_2\partial x_1} & \frac{\partial^2 f}{\partial x_2\partial x_2} & ... & \frac{\partial^2 f}{\partial x_2\partial x_d}\\ ... & ... & ... & ... \\ \frac{\partial^2 f}{\partial x_d\partial x_1} & \frac{\partial^2 f}{\partial x_d\partial x_2} & ... & \frac{\partial^2 f}{\partial x_d\partial x_d} \end{array} \right]_{d\times d}Positive Definite/Semi-Definite MatrixA real symmetric matrix $P$ is called Positive Semi-Definite (PSD) when for all $x \in \Re^n$, there are $x^TPx \geq 0$. And it’s called Positive Definite (PD) when for all $x \neq 0 \in \Re^n$, there are $x^TPx &gt; 0$. The equivalence of convex functionThere is a strong relationship between Convex Functions and their Hessians. Here is what I want to prove today. A $2^{nd}$-order differentiable function $f$ with convex domain $D$ is (strict) convex if and only if its Hessian is PSD (PD). This conclusion is also called the Second Order Condition of a convex function. To prove this, we need to introduce a First Order Condition that is A $1^{st}$-order differentiable function $f$ with convex domain $D$ is (strict) convex if and only if for any $x, y\in D$, $f(y) \geq f(x) + \nabla^T f(x)(y-x)$ Proof of First Order ConditionI divided the proof into two parts. Firstly we can prove that if $f$ is a convex function, then first order condition works.If $f$ is convex, we have f(tx+(1-t)y) = f(y+t(x-y)) = f(y) + t\nabla^Tf(y)(x-y) + t^2(x-y)^T\nabla^2f(y)(x-y) + o(t\|x-y\|) \leq tf(x)+(1-t)f(y).So, we can see tf(x) \geq tf(y) + t\nabla^Tf(y)(x-y) + t^2(x-y)^T\nabla^2f(y)(x-y) + o(t\|x-y\|) f(x) \geq f(y) + \nabla^Tf(y)(x-y) + t(x-y)^T\nabla^2f(y)(x-y) + \frac{o(t\|x-y\|)}{t}Let $t\rightarrow 0$, f(x) \geq f(y) + \nabla^Tf(y)(x-y)Then we can prove that, under the case of first order condition, $f$ is a convex function.If $f$ satisfy the first order condition, for all $x, y\in \Re^n$ and $t\in [0,1]$, we have f(x) \geq f(tx+(1-t)y) + \nabla^Tf(tx+(1-t)y)(x-(tx+(1-t)y)f(y) \geq f(tx+(1-t)y) + \nabla^Tf(tx+(1-t)y)(y-(tx+(1-t)y)Add them together, we have tf(x)+(1-t)f(y) \geq (t+(1-t))f(tx+(1-t)y) + [tx+(1-t)y-(t+1-t)(tx+(1-t)y)]\nabla^Tf(tx+(1-t)y) = f(tx+(1-t)y) + 0 = f(tx+(1-t)y)So $f(x)$ is a convex function. Proof of Second Order ConditionNow all prerequisites are proved, it’s turn to prove the Second Order Condition! Also, I depart the proof into two parts.First we prove that if the Hessian of $f$, $H$ is $PSD$, then $f$ is convex. If $f$ is PSD, there exists $\xi$ that f(x) = f(y) + \nabla^Tf(y)(y-x) + \frac{1}{2}(y-x)^T\nabla^2f(\xi)(y-x) \geq f(y) + \nabla^Tf(y)(y-x)So $f$ is convex due to the first order condition. Then we can prove the reverse part.If $f$ is convex, according to the first order condition, we suppose for all $y$, f(x+\lambda y) = f(x) + \lambda\nabla^Tf(x)y + \frac{1}{2}\lambda^2y^T\nabla^2f(x)y + o(\lambda^2\|y\|^2) \geq f(x) + \nabla^Tf(x)(x+\lambda y - x)Then, \frac{1}{2}\lambda^2y^T\nabla^2f(x)y + o(\lambda^2\|y\|^2) \geq 0 \Rightarrow y^T\nabla^2f(x)y + \frac{o(\lambda^2\|y\|^2)}{\frac{1}{2}\lambda^2} \geq 0Let $\lambda\rightarrow0$, we have $y^T\nabla^2f(x)y \geq 0$So $\nabla^2f(x)$ is PSD.]]></content>
      <categories>
        <category>Learning Notes</category>
      </categories>
      <tags>
        <tag>Optimization</tag>
        <tag>Linear Algebra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Solution: Best Time to Buy and Sell Stock]]></title>
    <url>%2F2019%2F09%2F05%2FLeetCode-Solution-Best-Time-Stock-to-Buy-and-Sell-Stock%2F</url>
    <content type="text"><![CDATA[IntroductionIn this article I will try to solve Best Time to Buy and Sell Stock series problem, including Best Time to Buy and Sell Stock I, II, III, IV and with Cooldown. Most of them are solved by dynamic programming and I will focus on construct transition equation and dimension reduction. DescriptionThe description of Best Time to Buy and Sell Stock I is: Say you have an array for which the $i^{th}$ element is the price of a given stock on day $i$. If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit. Note that you cannot sell a stock before you buy one. Example: 123Input: [7,1,5,3,6,4]Output: 5Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Solution of Problem IA simple idea is using dp[i] as the most profit buying in $i^{th}$ day. Then the transition equation will be dp[i] = max(prices[j] - prices[i]) for all j &gt; i and the soluton is max(dp). It will be an $O(n^2)$ algorithm. But there is a waste of computation in this method. We suppose $j$ is the specific day that dp[i] = prices[j] - prices[i], then if there is a $k$ makes $dp[k] &lt; dp[i]$ and $k &gt; i$, then we have dp[k] = max(prices[l] - prices[i]) > prices[j] - prices[k] > dp[i].So the soluton won’t be dp[i]. Under this circumstance, we cam simplify our algorithm by always searching lower price day as buying day, record the current price minus buying day price(the lowest price before/on current $i^{th}$ day) and generate a sequence of profit. The profit[i] means the difference between $i^{th}$ day price and the lowest price before/on $i^{th}$ day. So max(profit) will be the solution. By doing so, we reduce the method into $O(n)$ time. Here is the cpp code. 123456789101112131415class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; int buy = prices[0]; int maxPro = 0; for(int price:prices)&#123; if(price &lt; buy)&#123; buy = price; &#125; maxPro = max(maxPro, price-buy); &#125; return maxPro; &#125;&#125;; Solution of Problem IIIn problem II, we have not the transaction number limitation, we can buy/sell any times. When we try to using the dp[i] as above, we find that it’s hard to build a transition equation because we don’t know how many transaction times there will be. We have to change our state description. We have only three actions in a day, buying, selling and doing nothing, so we can use two states to describe a day, i.e. a day with stock and a day without stock. Let nohold[i] be the maximal profit when we have not stock in $i^{th}$ day, hold[i] be the maximal profit when we have stock. Then the transition equation will be 12hold[i] = max(hold[i-1], nohold[i-1] - prices[i]);nohold[i] = max(hold[i-1] + prices[i], nohold[i-1]); That simply means if we have stock in $i^{th}$ day, the stock can be bought today or we already have it yesterday and if we have stock in $i^{th}$ day, the stock can be sold today or yesterday or before. By this equation, we can solve this problem in one pass. Don’t forget the initialization nohold[0] = -prices[0]. 1234567891011121314class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; vector&lt;int&gt; nohold(prices.size(), 0); vector&lt;int&gt; hold(prices.size(), 0); hold[0] = -prices[0]; for(int i = 1; i &lt; prices.size(); i++)&#123; hold[i] = max(hold[i-1], nohold[i-1] - prices[i]); nohold[i] = max(hold[i-1] + prices[i], nohold[i-1]); &#125; return nohold[nohold.size()-1]; &#125;&#125;; There is another solution do not use DP. A trivial idea is that we buy all the stock at the begin of an increasing line and sell it at the end of line, we can get the most profit. 12345678910class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int maximal = 0; for(int i = 1; i &lt; prices.size(); i++)&#123; if(prices[i] &gt; prices[i-1]) maximal += prices[i] - prices[i-1]; &#125; return maximal; &#125;&#125;; Soluton of III &amp; IVProblem III is a special case of Problem IV, so we just introduce Problem IV. In Problem IV, we have a limitation that we can only buy $k$ times($k$ is given). It can be solved simply like the DP algorithm of Problem II. We can use similar state description and just increase a dimension of transaction times. Let hold[i][j] as the maximal profit when we have stock and $j$ transitions on $i^{th}$ day and nohold[i][j] as the maximal profit when we have no stock and have $j$ transitions on $i^{th}$ day. Also like Problem II, the transition equation can be written as 12hold[i][j] = max(hold[i-1][j], nohold[i-1][j-1] - prices[i]);nohold[i][j] = max(nohold[i-1][j], hold[i-1][j] + prices[i]); The solution will be nohold[n-1][k-1]. What need to be mentioned is that we counting transaction by counting buying numbers but not selling. Then it’s a one-pass method. 12345678910111213141516171819202122class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(prices.empty() || k==0) return 0; int n = prices.size(); vector&lt;vector&lt;int&gt;&gt; hold(n, vector&lt;int&gt;(k, 0)), nohold(n, vector&lt;int&gt;(k, 0)); //hold[0][0] = -prices[0]; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; k; j++)&#123; if(i &gt; 0)&#123; if(j &gt; 0) hold[i][j] = max(hold[i-1][j], nohold[i-1][j-1] - prices[i]); else hold[i][j] = max(hold[i-1][j], -prices[i]); nohold[i][j] = max(nohold[i-1][j], hold[i-1][j] + prices[i]); &#125; else hold[i][j] = -prices[i]; &#125; &#125; return nohold[n-1][k-1]; &#125;&#125;; But the code did not pass! We got a Memory Limit Exceeded. So I start to reduce the dimension of the equation. Obviously, both hold[i][j] and nohold[i][j] have only relationship with hold[i-1][*] and nohold[i-1][*]. So we can just reduce it as 12hold[j] = max(hold[j], nohold[j-1] - prices[i]);nohold[j] = max(nohold[j], hold[j] + prices[i]); Also, using a sentinel $0$ in nohold[j] can make code looks better(reduce the number of $if$). So we get the code like this. 12345678910111213141516class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(prices.empty() || k==0) return 0; int n = prices.size(); vector&lt;int&gt; hold(k, INT_MIN), nohold(k+1, 0); hold[0] = -prices[0]; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; k; j++)&#123; hold[j] = max(hold[j], nohold[j] - prices[i]); nohold[j+1] = max(nohold[j+1], hold[j] + prices[i]); &#125; &#125; return nohold[k]; &#125;&#125;; ~Ok, we have already solved it!~ Wait, it’s still Memory Limit Exceeded! But why? If we consider a super large $k$ that the limitation is meaningless to the problem, the problem reduces into Problem II. But the time complexity of our solution will still be $O(k*\dot n)$, which is a super large number especially comparing with $O(n)$ solution in Problem II. We can solve this by a simple $if$ sentence. 123456if(k &gt; n/2)&#123; int res = 0; for(int i = 1; i &lt; prices.size(); i++) res = max(res, res + prices[i]-prices[i-1]); return res;&#125; And here is the whole program of Problem IV. 1234567891011121314151617181920212223class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; if(prices.empty() || k==0) return 0; int n = prices.size(); if(k &gt; n/2)&#123; int res = 0; for(int i = 1; i &lt; prices.size(); i++) res = max(res, res + prices[i]-prices[i-1]); return res; &#125; vector&lt;int&gt; hold(k, INT_MIN), nohold(k+1, 0); hold[0] = -prices[0]; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; k; j++)&#123; hold[j] = max(hold[j], nohold[j] - prices[i]); nohold[j+1] = max(nohold[j+1], hold[j] + prices[i]); &#125; &#125; return nohold[k]; &#125;&#125;; Solution of Problem with CooldownCooldown means we have to ~have relax and take a coffee~ the day after selling. Buying the day after a selling is not allowed. That means our states description above can not be used again…Of course not! We can just do a little modification, adding a new vector called cooldown[i] means the maximal profit when we just sell or do nothing on the $i^{th}$ day. We have have_stock[i] and have_no_stock[i] as above. We can find the transition of cooldown like cooldown[i] = max(hold_no_stock[i-1], hold_stock[i-1] + prices[i]) which means today we sell the stock or do nothing. The transition of hold_stock is still hold_stock[i] = max(hold_stock[i-1], hold_no_stock[i-1] - prices[i]) because cooldown doesn’t influence buying. Finally the transition equation pf hold_no_stock[i] can be hold_no_stock[i] = max(hold_no_stock[i-1], cooldown[i-1]), meaning that today is a cooldown day or no stock day. Combine them together we have_stock 123hold_no_stock[i] = max(hold_no_stock[i-1], cooldown[i-1]);hold_stock[i] = max(hold_stock[i-1], hold_no_stock[i-1] - prices[i]);cooldown[i] = max(hold_no_stock[i-1], hold_stock[i-1] + prices[i]); Don’t forget the initialization hold_stock[0] = -prices[0]; cooldown[0] = INT_MIN;. It’s also a $O(n)$ one-pass method now. In conclusion, all these kind of problem can be solved by dynamic programming idea and the basic idea is to form transition equation. The number of variables or the number of dimensions are equivalent in constructing equation. So if you have not idea how to form the equation, including the variable number of state will be a good choice. 12345678910111213141516class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if(prices.empty()) return 0; int n = prices.size(); vector&lt;int&gt; hold_stock(n, 0), hold_no_stock(n, 0), cooldown(n, 0); hold_stock[0] = -prices[0]; cooldown[0] = INT_MIN; for(int i = 1; i &lt; n; i++)&#123; hold_no_stock[i] = max(hold_no_stock[i-1], cooldown[i-1]); hold_stock[i] = max(hold_stock[i-1], hold_no_stock[i-1] - prices[i]); cooldown[i] = max(hold_no_stock[i-1], hold_stock[i-1] + prices[i]); &#125; return max(cooldown[cooldown.size()-1], hold_no_stock[hold_no_stock.size()-1]); &#125;&#125;;]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Solution: #300 Longest Increasing Subsequence]]></title>
    <url>%2F2019%2F09%2F01%2FLeetCode-Solution-300-Longest-Increasing-Subsequence%2F</url>
    <content type="text"><![CDATA[IntroductionIn this article I will describe two dynamic programming algorithms solving LIS problem and STL functions lower_bound() and upper_bound(). DescriptionGiven an unsorted array of integers, find the length of longest increasing subsequence.Example: Input: $[10,9,2,5,3,7,101,18]$Output: 4Explanation: The longest increasing subsequence is $[2,3,7,101]$, therefore the length is $4$. $O(n^2)$ Dynamic Programming SolutionHere is a trivial description that dp[i] means the length of longest increasing subsequence with $i^{th}$ element. Also, we can find easily that the value of dp[i] can be determined by all increasing subsequence with $j &lt; i$ that maintain increasing property with $i^{th}$ value. Mathematically, dp[i] is determined by all the value dp[j] with $j &lt; i$ and $nums[i] &gt; nums[j]$ which nums is the input vector. So the state transition equation is dp[i] = max(dp[j]) + 1 with j &lt; i, nums[j] &lt; nums[i] This method need two iterations so it’s a $O(n^2)$ algorithm. 1234567891011121314151617class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; dp(n, 0); int ret = 0; for(int i = 0; i &lt; n; i++)&#123; int maximal = 0; for(int j = 0; j &lt; i; j++) if(nums[j] &lt; nums[i]) maximal = max(maximal, dp[j]); dp[i] = maximal + 1; ret = max(ret, dp[i]); &#125; return ret; &#125;&#125;; $O(nlgn)$ Dynamic Programming SolutionComparing all optimal subsequences with the same length, the one with least last number will confirm that when a new number is added in, the new subsequence will still optimal. For example, for subsequence $[1,3,5,2,7,4,5]$, we have two subsequences length $4$: [1,3,5,7], [1,2,4,5]Then we add $6$ into the sequence, the first subsequence is still $[1,3,5,7]$ when the second one becomes $[1,2,4,5,6]$. But how to guarantee that the subsequence has the least last number? We can do so by replacing the number just larger than the new number with the new number. It’s because the replacement won’t change the length of the subsequence but will decrease the number value generally.There is a very great property that the increasing subsequences are ‘increasing’, which means that given a increasing subsequence and a new number, we can find the correct position of the new number in the subsequence in only $O(lgn)$ time. We can generate a new largest increasing subsequence including the new number by adding the new number if it’s larger than all numbers in the subsequence and do replacing if not. The whole time complexity will be $O(nlgn)$. 1234567891011121314class Solution &#123;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; dp; int ret = 0; for(int i = 0; i &lt; n; i++)&#123; auto it = lower_bound(dp.begin(), dp.end(), nums[i]); if(it == dp.end()) dp.push_back(nums[i]); else *it = nums[i]; &#125; return dp.size(); &#125;&#125;; lower_bound and upper_bound in STLWe can mention that I use lower_bound function in the previous code. It’s a binary search function in STL. Both it ans upper_bound use binary search and return a position of a vector. The difference is that lower_bound return the position of the first number larger than or equals to the target and upper_bound return the position of the first number strictly larger than the target. There are three parameters in both functions. The first parameter is a Iterator refers to the search begin position, the second parameter is a Iterator refers to the end position and the third parameter is target number. Here is the source code of lower_bound. 1234567891011121314151617template &lt;class ForwardIterator, class T&gt; ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T&amp; val)&#123; ForwardIterator it; iterator_traits&lt;ForwardIterator&gt;::difference_type count, step; count = distance(first,last); while (count&gt;0) &#123; it = first; step=count/2; advance (it,step); if (*it&lt;val) &#123; // or: if (comp(*it,val)), for version (2) first=++it; count-=step+1; &#125; else count=step; &#125; return first;&#125; What should be mentioned is that the begin position will be included but the end position won’t be included. The function uses binary search, so the time complexity is $O(lgn)$ where $n$ is the size between two pointers.]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Algorithm</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Solution: #146 LRUcache]]></title>
    <url>%2F2019%2F08%2F28%2FLeetcode-Solution-LRUcache%2F</url>
    <content type="text"><![CDATA[DescriptionDesign and implement a data structure for Least Recent Used(LRU) cache. It should support the following operations: get and put. get(key) -Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) -Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. The cache is initialized with a positive capacity. Basic IdeaTo solve this problem, we need to design a kind of data structure with the properties as follow: The data structure can visit the and set/insert the item as soon as possible(such as vector or map). The data structure can order the data by the operation time. The data structure can quickly check for the overflow of capacity. Due to the data structure in different language is not the same, I will choose python and cpp as my solution language. Python solutionI will introduce a kind of python data structure called OrderedDict. This is a kind of dictionary(in fact it is inherited from ‘dictionary’ of python) with the order of insertion time. Python uses an extra circular linked list to save the node as form $[PREV, NEXT, KEY]$ to realize the data structure. Obviously, this data structure is perfectly suitable for our problem. The only problem we need to solve is the question is to find a data structure ordering by operation time but not the insertion time. So we just need to simply delete and insert every operation to solve this problem. 12345678910111213141516171819202122232425262728class LRUCache: import collections def __init__(self, capacity: int): self.capacity = capacity self.cache = collections.OrderedDict() def get(self, key: int) -&gt; int: if key in self.cache: ret = self.cache[key] del self.cache[key] self.cache[key] = ret return ret return -1 def put(self, key: int, value: int) -&gt; None: if key in self.cache: del self.cache[key] if self.capacity == len(self.cache): #This for iteration is to visit the first value of cache. for i in self.cache.keys(): del self.cache[i] break self.cache[key] = value# Your LRUCache object will be instantiated and called as such:# obj = LRUCache(capacity)# param_1 = obj.get(key)# obj.put(key,value) Cpp solution(using STL container)CPP provides many kinds of STL containers, but there are nothing like the ‘OrderedDict’ in python. The design idea is to combine two or more kinds of containers(like the OrderedDict source code do). If we want to build a structure with insertion order, stack will be a first choice. But what we also want is to keep the high speed of insertion and deletion of map/vector, which will conflict with stack’s properties that we can not move/delete a node in the middle of a stack. Therefore, Linked List(in STL is list) will be a great choice, which also matches python’s choice. To keep the order of operation time, the problem we need to solve can be as follow: We need a fast way to visit/insert/delete a node in linked list given key. We need a fast way to move a node to the front of linked list after every operation. When we get the first value of linked list, we need a fast way to delete the pair in map/vector. These properties keeps a linked list by operation time order with short modifying time. Actually, property $1$ and $2$ can be combined due to the property of Linked List. Map can be a good way to satisfy property $1$ and $2$. We can use map(key, node) form to visit a linked list node quickly in $O(1)$ time. About property $3$, we need a reverse_map(value, key) to fast delete corresponding pair in map. We just need to delete reverse_map[node.value] in map. But it’s not convenient and cost extra space. We can just store node(value, key) in linked list to do the same thing. In conclusion, what we need is to combine a map(or unordered_map) and a list. 1234567891011121314151617181920212223242526272829303132class LRUCache &#123;public: LRUCache(int capacity) &#123; this-&gt;cache = map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt;(); this-&gt;linkedlist = list&lt;pair&lt;int, int&gt;&gt;(); this-&gt;cap = capacity; &#125; int get(int key) &#123; auto it = cache.find(key); if(it != cache.end())&#123; linkedlist.splice(linkedlist.begin(), linkedlist, it-&gt;second); return it-&gt;second-&gt;second; &#125; else return -1; &#125; void put(int key, int value) &#123; auto it = cache.find(key); if(it != cache.end()) linkedlist.erase(it-&gt;second); linkedlist.push_front(&#123;key, value&#125;); cache[key] = linkedlist.begin(); if(cache.size() &gt; cap)&#123; int key_recent = linkedlist.back().first; cache.erase(key_recent); linkedlist.pop_back(); &#125; &#125;private: map&lt;int, list&lt;pair&lt;int, int&gt;&gt;::iterator&gt; cache; list&lt;pair&lt;int, int&gt;&gt; linkedlist; int cap;&#125;; There are also some tricky cases like we need to check for if key in the cache first because change a value in cache need to delete the value first and then insert a new one. The combination of STL containers is not the only way to solve this problem. Actually many artificial data structures have better performance. A specific example is using circular linked list nodes just like python do in the ‘OrderedDict’. I won’t cover this method here and you can find related articles easily.]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Data Structure</tag>
        <tag>Cpp</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Solution: #142 Linked List Circle]]></title>
    <url>%2F2019%2F08%2F27%2FLeetcode-Solution-Linked-List-Circle-0%2F</url>
    <content type="text"><![CDATA[DescriptionGiven a linked list and return where the circle begins. For example, a linked list $[3, 2, 0, 4]$ having circle $[2, 0, 4]$ is shown below. The algorithm should return the second node. I use C++ to solve this problem and define the node as below. 123456//Definition for singly-linked list.struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;; Solution 1: hashsetA trivial idea to solve this problem is saving the node information in a hashset when traversing and find if there is a visited node. 123456789101112131415class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; ListNode *cur = head; unordered_set&lt;ListNode*&gt; storage; while(cur!=NULL)&#123; if (storage.find(cur)!=storage.end())&#123; return cur; &#125; storage.insert(cur); cur = cur-&gt;next; &#125; return NULL; &#125;&#125;; This is a method with O(n) time complexity and O(n) space complexity. But if there is a method to solve this problem with O(1) space complexity? Solution 2: fast and slow pointersSet two pointers which slower one move one time one step and faster one move one time two steps. Once they meet, reset the faster one to the head pointer, then finally they will meet in the begin node of circle. This is an algorithm without extra space. But why it works? There is a mathematical idea. Suppose the distance from head node to the begin of circle is $x_1$, the distance from begin of circle and meeting point on the circle is $x_2$, the distance from meeting point back to the begin of the circle is $x_3$. Then there is the velocity equation. 2*((x_1 + x_2) + k_1(x_2+x_3)) = (x_1 + x_2) + k_2 (x_2+x_3)-> x_1 + x_2 = (k_2 - 2*k_1 - 1)(x_2 + x_3)-> (x_2 + x_3)|(x_1 + x_2)It means that the difference between $x_3$ and $x_1$ is the multiple of circle length. Due to the definition of $x_3$ and $x_1$, if the fast pointer move from the head node when the slow pointer move from the meeting point, finally the slow pointer and fast pointer will meet on the begin of the circle. 12345678910111213141516171819class Solution &#123;public: ListNode *detectCycle(ListNode *head) &#123; if(head == NULL || head-&gt;next == NULL || head-&gt;next-&gt;next == NULL) return NULL; ListNode* fast = head-&gt;next-&gt;next; ListNode* slow = head-&gt;next; while(fast != slow)&#123; if(fast-&gt;next == NULL || fast-&gt;next-&gt;next == NULL) return NULL; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; fast = head; while(fast != slow)&#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return slow; &#125;&#125;; Don’t forget the special cases of NULL pointer and if fast pointer move to NULL means there is no circle.]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
